## Iteration 1: Set up Vitest testing framework

Task: PRD Task 1.1 - Set up Vitest testing framework

Decisions:
- Used Vitest v2.1.9 with v8 coverage provider
- Configured for Node environment with globals enabled
- Set include pattern: src/**/*.{test,spec}.{ts,tsx}
- Added @vitest/coverage-v8 for coverage reporting
- Excluded standard files from coverage (tests, bin, d.ts files)

Files changed:
- package.json: Added vitest and @vitest/coverage-v8 devDeps, added test scripts (test, test:watch, test:coverage)
- vitest.config.ts: Created config with Node env, coverage settings, and path alias

Notes:
- Test framework is ready, no test files exist yet (expected)
- Next tasks will add actual test files for session, config, claude, and git modules

## Iteration 2: Add unit tests for session management

Task: PRD Task 1.2 - Add unit tests for session management (src/lib/session.ts)

Decisions:
- Created comprehensive test suite with 24 tests covering all session.ts functions
- Mocked node:fs, node:fs/promises, and use-git hooks using vi.mock
- Tested all public APIs: loadSession, saveSession, createSession, saveCheckpoint, resumeFromCheckpoint, addIterationResult, clearSession, canResumeSession
- Used proper TypeScript types for mock data (SessionState, IterationResult)

Files changed:
- src/lib/session.test.ts: Created comprehensive test suite with 24 passing tests

Test coverage:
- loadSession: 5 tests (missing file, invalid JSON, missing fields, valid session, session with checkpoint)
- saveSession: 2 tests (create directory, directory exists)
- createSession: 4 tests (provided branch, current branch, git failures, unique IDs)
- saveCheckpoint: 2 tests (with commit, without commit)
- resumeFromCheckpoint: 3 tests (no session, no checkpoint, with checkpoint)
- addIterationResult: 3 tests (cumulative cost, missing usage, initialize cost)
- clearSession: 2 tests (file exists, file missing)
- canResumeSession: 3 tests (no session, no checkpoint, with checkpoint)

Notes:
- All tests pass
- Mocks ensure tests are isolated and don't touch filesystem
- Next: Add tests for config.ts

## Iteration 3: Add unit tests for configuration loading

Task: PRD Task 1.3 - Add unit tests for configuration loading (src/lib/config.ts)

Decisions:
- Created comprehensive test suite with 18 tests covering loadConfig function
- Mocked node:fs/promises readFile using vi.mock
- Tested all config parsing scenarios: defaults, quotes, booleans, numbers, errors
- Verified proper handling of SCREAMING_SNAKE_CASE to camelCase conversion
- Tested $SCRIPT_DIR variable expansion
- Verified graceful error handling (missing file, permission errors)

Files changed:
- src/lib/config.test.ts: Created test suite with 18 passing tests

Test coverage:
- Default config when file missing (ENOENT)
- Valid config file parsing with all fields
- Comments and empty lines handling
- Quote parsing (double and single)
- $SCRIPT_DIR variable expansion
- Boolean parsing (true/false, TRUE/False, 1/0)
- Invalid numeric value handling (fallback to defaults)
- Negative cost value rejection
- Lines without equals sign (skip gracefully)
- Empty string values (use defaults)
- Case conversion (SCREAMING_SNAKE_CASE to camelCase)
- Floating point cost values
- Non-ENOENT errors (continue with defaults)
- Partial config (merge with defaults)
- Whitespace around keys/values
- Unknown config keys (ignored)

Notes:
- All 42 tests pass (18 config + 24 session)
- Config parsing is robust with proper fallbacks
- Next: Add tests for claude.ts

## Iteration 4: Add unit tests for Claude integration

Task: PRD Task 1.4 - Add unit tests for Claude integration (src/lib/claude.ts)

Decisions:
- Created comprehensive test suite with 25 tests covering claude.ts functions
- Mocked @anthropic-ai/claude-agent-sdk query function using vi.mock
- Mocked execa for CLI version checks
- Mocked keychain module for API key operations
- Created async iterable helper to properly mock SDK streaming responses
- Tested all public APIs: runClaude, hasApiKey, hasApiKeySync, setApiKey, isClaudeCodeInstalled, getClaudeCodeVersion

Files changed:
- src/lib/claude.test.ts: Created test suite with 25 passing tests

Test coverage:
- runClaude: 10 tests (PRD read error, missing progress, valid run, PRD completion, onStdout callback, onStatus callback with tool use, SDK errors, resume session, multiple text blocks)
- hasApiKey: 3 tests (env var set, keychain fallback, no key found)
- hasApiKeySync: 2 tests (env var set/not set)
- setApiKey: 4 tests (env only, keychain persist, default persist, keychain failure)
- isClaudeCodeInstalled: 3 tests (command succeeds, fails, throws)
- getClaudeCodeVersion: 4 tests (success, failure, throws, whitespace trim)

Notes:
- All 67 tests pass (25 claude + 18 config + 24 session)
- SDK streaming properly mocked with async iterables
- Callback functions tested for stdout and status updates
- Next: Add tests for git operations (use-git.ts)

## Iteration 5: Add unit tests for git operations

Task: PRD Task 1.5 - Add unit tests for git operations (src/hooks/use-git.ts)

Decisions:
- Created comprehensive test suite with 26 tests covering use-git.ts functions
- Mocked execa using vi.mock for all git commands
- Tested all public APIs: getRepoRoot, isGitRepo, getCurrentBranch, getCurrentCommit, createBranch, getCommitsSince, getDiffStats
- Used Awaited<ReturnType<typeof execa>> for proper type casting

Files changed:
- src/hooks/use-git.test.ts: Created test suite with 26 passing tests

Test coverage:
- getRepoRoot: 3 tests (success, failure, whitespace trim)
- isGitRepo: 2 tests (in repo, not in repo)
- getCurrentBranch: 4 tests (success, failure, empty output, whitespace)
- getCurrentCommit: 3 tests (success, failure, whitespace)
- createBranch: 3 tests (new branch, existing branch fallback, both fail)
- getCommitsSince: 5 tests (valid commits, empty, failure, pipe chars in message, missing fields)
- getDiffStats: 6 tests (valid stats, empty, failure, binary files, empty nameStatus, tabs in filename)

Notes:
- All 93 tests pass (26 git + 25 claude + 18 config + 24 session)
- Git operations properly mocked with execa
- Edge cases covered: whitespace, empty outputs, binary files, special characters
- Next: Update CI workflow to run tests

## Iteration 6: Update CI workflow to run tests

Task: PRD Task 1.6 - Update CI workflow to run tests

Decisions:
- Added `pnpm test` step to .github/workflows/ci.yml after format check
- Verified format check already exists (PRD Task 2.1 already complete)
- Tests run after type check, lint, and format check in CI pipeline
- Uses existing pnpm cache and Node 22 setup

Files changed:
- .github/workflows/ci.yml: Added test step to CI check job

Notes:
- CI workflow now runs all quality checks: types, lint, format, tests
- All 93 tests pass locally
- Format check was already implemented in CI (Task 2.1 complete)
- Next: Implement cost limit enforcement or error message improvements

## Iteration 7: Add automated publishing on version tags

Task: PRD Task 2.2 - Add automated publishing on version tags

Decisions:
- Release workflow already exists and triggers on v* tags
- Added missing quality checks: format check and tests
- Workflow now runs all checks before publishing: types, lint, format, tests
- Uses GitHub Package Registry with GITHUB_TOKEN
- Triggers on both GitHub releases and v* tag pushes

Files changed:
- .github/workflows/release.yml: Added format check and test steps before publish

Notes:
- Release workflow complete with comprehensive quality gates
- Publishes to GitHub Package Registry (@stafftraveler scope)
- All 93 tests pass, ensuring quality before any release
- Next: Implement cost limit enforcement features

## Iteration 8: Implement pre-iteration cost limit check

Task: PRD Task 3.1 - Implement pre-iteration cost limit check

Decisions:
- Added cost limit check in handleIterationComplete callback in App.tsx
- Check happens AFTER a successful iteration and BEFORE starting the next one
- Positioned after retry count reset (line 414) and before iteration increment (line 429)
- Uses existing config.maxCostPerSession configuration value
- Gracefully stops execution by transitioning to "summary" phase
- Provides clear error message with formatted costs showing limit exceeded

Files changed:
- src/components/App.tsx: Added cost limit enforcement in handleIterationComplete
  - Imported formatCost from utils.js
  - Added check comparing updatedSession.totalCostUsd against config.maxCostPerSession
  - If limit exceeded, sets error message and transitions to summary phase
  - Error message format: "Session cost limit reached: $X.XX / $Y.YY. Stopping after iteration N of M."

Implementation details:
- Check location: Between line 414 (retry count reset) and line 429 (next iteration start)
- Uses optional chaining for updatedSession.totalCostUsd with fallback to 0
- Only enforces limit if maxCostPerSession is defined (undefined means no limit)
- Uses formatCost utility for consistent cost display in error messages
- Sets phase to "summary" to ensure graceful shutdown with proper cleanup

Notes:
- All 93 tests pass
- Quality checks pass: format, lint, type check
- Cost enforcement prevents starting new iterations when limit reached
- Complements existing cost warning display at 80% threshold in IterationRunner
- Next: Add cost warning threshold display in UI (Task 3.2)

## Iteration 9: Add cost warning threshold display

Task: PRD Task 3.2 - Add cost warning threshold (80% of MAX_COST_PER_SESSION)

Decisions:
- Modified UsageDisplay component to automatically calculate 80% warning from maxCostPerSession
- Removed separate warnCostThreshold config field (was redundant)
- Warning now derives from maxCostPerSession * 0.8 automatically
- Yellow warning displays when session cost >= 80% of limit
- Red warning displays when session cost >= 100% of limit
- Shows percentage and "Approaching cost limit" message

Files changed:
- src/components/IterationRunner.tsx:
  - Updated UsageDisplay to use maxCostPerSession instead of warnCostThreshold
  - Calculate 80% threshold inline: maxCostPerSession * 0.8
  - Display shows session total and max limit when maxCostPerSession is set
  - Warning at 80%: "⚠ Approaching cost limit (X%)" in yellow
  - Warning at 100%: "⚠ Cost limit exceeded!" in red

- src/types.ts:
  - Removed warnCostThreshold field from RalphConfig
  - Updated maxCostPerSession doc comment to mention 80% warning

- src/lib/config.ts:
  - Removed warnCostThreshold from DEFAULT_CONFIG
  - Removed warnCostThreshold parsing case

- src/lib/config.test.ts:
  - Removed all warnCostThreshold test assertions
  - Removed WARN_COST_THRESHOLD from test config content
  - All 93 tests still passing

Implementation details:
- Warning threshold calculated as: const warnThreshold = maxCostPerSession !== undefined ? maxCostPerSession * 0.8 : undefined
- isApproachingLimit checks: sessionTotal >= warnThreshold
- hasExceededLimit checks: sessionTotal >= maxCostPerSession
- Percentage display: Math.round((sessionTotal / maxCostPerSession) * 100)
- Type-safe with proper undefined checks

Notes:
- All 93 tests pass
- Quality checks pass: format, lint, type check
- Simpler than separate config field - one setting controls both warning and limit
- Warning automatically appears when approaching limit without extra config
- Next: Add --max-cost CLI flag (Task 3.3)

## Iteration 10: Add --max-cost CLI flag

Task: PRD Task 3.3 - Add --max-cost CLI flag to override MAX_COST_PER_SESSION

Decisions:
- Added --max-cost <amount> flag to CLI run command
- CLI flag overrides config MAX_COST_PER_SESSION value
- Accepts floating point USD amounts (e.g., --max-cost 5.50)
- Shows in dry-run output as "$X.XX" or "from config" if not set
- Integrated cleanly with existing config system

Files changed:
- src/types.ts:
  - Added maxCost?: number to CliOptions interface
  - Documented as "Override MAX_COST_PER_SESSION from CLI"

- src/cli.ts:
  - Added .option("--max-cost <amount>", "Override MAX_COST_PER_SESSION from config (in USD)")
  - Parse maxCost from opts.maxCost using parseFloat with validation
  - Added maxCost to all option initialization locations (run action, init action, getParsedArgs default)
  - Updated dry-run display to show max cost value

- src/components/App.tsx:
  - Merge CLI maxCost with config maxCostPerSession in initialization
  - CLI flag takes precedence: options.maxCost ?? loadedConfig.maxCostPerSession
  - Added options.maxCost to useEffect dependency array

Implementation details:
- Parsing: const parsed = Number.parseFloat(opts.maxCost); validates and converts string
- Validation: if (!Number.isNaN(parsed) && parsed > 0) ensures positive values only
- Merge logic: maxCostPerSession: options.maxCost ?? loadedConfig.maxCostPerSession
- Display format: options.maxCost !== undefined ? `$${options.maxCost.toFixed(2)}` : "from config"

Notes:
- All 93 tests pass
- Quality checks pass: format, lint, type check
- CLI flag provides flexible cost limit override without editing config
- Works seamlessly with existing cost enforcement and warning system
- Next: Show cost projections (Task 3.4)

## Iteration 11: Add cost projections

Task: PRD Task 3.4 - Show cost projections based on previous iterations

Decisions:
- Calculate average cost from completed iterations in session
- Display projected total cost for remaining iterations
- Show average cost per iteration alongside projection
- Warn if projected cost would exceed maxCostPerSession limit
- Only show projections when previous iteration data available

Files changed:
- src/components/IterationRunner.tsx:
  - Added previousIterations prop to IterationRunnerProps
  - Added currentIteration, totalIterations, previousIterations to UsageDisplayProps
  - Calculate avgCostPerIteration from previousIterations with usage data
  - Project remaining cost: avgCostPerIteration * remainingIterations
  - Project total cost: sessionTotal + projectedRemainingCost
  - Display "Projected total: $X.XX (avg $Y.YY/iter)" when data available
  - Show yellow warning "⚠ Projected cost would exceed limit" if projection > maxCostPerSession
  - Warning shown only when not already showing other warnings (exceeded/approaching)

- src/components/App.tsx:
  - Pass session.iterations as previousIterations prop to IterationRunner

Implementation details:
- Extract costs: previousIterations.map(iter => iter.usage?.totalCostUsd ?? 0).filter(cost => cost > 0)
- Average calculation: costsFromPrevious.reduce((sum, cost) => sum + cost, 0) / costsFromPrevious.length
- Remaining iterations: totalIterations - currentIteration
- Projection warning logic: projectionWouldExceedLimit && !hasExceededLimit && !isApproachingLimit
- Graceful handling when no previous iteration cost data exists

Notes:
- All 93 tests pass
- Quality checks pass: format, lint, type check
- Projections help users anticipate cost overruns before they happen
- Based on actual iteration costs, not estimates
- Complements existing 80% warning and hard limit enforcement
- Next: Section 4 - Improve Error Messages (multiple tasks)
